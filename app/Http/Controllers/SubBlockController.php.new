<?php

namespace App\Http\Controllers;

use App\Models\SubBlock;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Validator;
use Yajra\DataTables\Facades\DataTables;

class SubBlockController extends Controller
{
    // Middleware auth sementara dinonaktifkan untuk testing
    // public function __construct()
    // {
    //     $this->middleware('auth');
    // }

    public function index(Request $request)
    {
        try {
            // Debug: Log request data
            Log::info('SubBlock index request', ['request' => $request->all()]);

            $query = SubBlock::query();

            // Search functionality
            if ($request->filled('kode_petak')) {
                $query->where('kode_petak', 'like', '%' . $request->kode_petak . '%');
            }

            // Get distinct estates
            $estates = SubBlock::select('estate')
                ->distinct()
                ->orderBy('estate')
                ->pluck('estate');

            // Get divisions grouped by estate
            $estatesWithDivisions = [];
            foreach ($estates as $estate) {
                $estatesWithDivisions[$estate] = SubBlock::where('estate', $estate)
                    ->select('divisi')
                    ->distinct()
                    ->orderBy('divisi')
                    ->pluck('divisi')
                    ->toArray();
            }

            $subblocks = $query->paginate(13)->onEachSide(1);

            // Set breadcrumb
            $breadcrumb = [
                ['title' => 'Dashboard', 'url' => route('dashboard')],
                ['title' => 'List Sub Block']
            ];

            return view('backend.subblock.index', [
                'subblocks' => $subblocks,
                'estates' => $estates,
                'estatesWithDivisions' => $estatesWithDivisions,
                'breadcrumb' => $breadcrumb
            ]);
        } catch (\Exception $e) {
            Log::error('Error in SubBlockController@index: ' . $e->getMessage());
            return back()->with('error', 'Gagal memuat data sub block: ' . $e->getMessage());
        }
    }

    public function create()
    {
        try {
            // Get all unique estates with their divisions
            $estatesData = SubBlock::select('estate')
                ->distinct()
                ->orderBy('estate')
                ->get()
                ->mapWithKeys(function($item) {
                    $displayName = str_replace('Estate ', '', $item->estate);
                    return [$displayName => $item->estate];
                });

            $estates = $estatesData->keys()->unique()->values();
            $estatesWithDivisions = [];

            // Build the divisions array with display names as keys
            foreach ($estatesData as $displayName => $estate) {
                $estatesWithDivisions[$displayName] = SubBlock::where('estate', $estate)
                    ->select('divisi')
                    ->distinct()
                    ->orderBy('divisi')
                    ->pluck('divisi')
                    ->toArray();
            }

            // Set breadcrumb
            $breadcrumb = [
                ['title' => 'List Sub Block', 'url' => route('sub-blocks.index')],
                ['title' => 'Tambah Sub Block']
            ];

            return view('backend.subblock.create', [
                'estates' => $estates,
                'estatesWithDivisions' => $estatesWithDivisions,
                'breadcrumb' => $breadcrumb
            ]);
        } catch (\Exception $e) {
            Log::error('Error in SubBlockController@create: ' . $e->getMessage());
            return back()->with('error', 'Gagal memuat form tambah sub block: ' . $e->getMessage());
        }
    }

    public function store(Request $request)
    {
        try {
            $validator = Validator::make($request->all(), [
                'kode_petak' => 'required|string|max:50|unique:sub_blocks,kode_petak',
                'estate' => 'required|string|max:100',
                'divisi' => 'required|string|max:100',
                'blok' => 'required|string|max:50',
                'luas_area' => 'required|numeric|min:0',
                'zona' => 'nullable|string|max:50',
                'keterangan' => 'nullable|string|max:255',
                'aktif' => 'boolean',
                'geom_json' => 'nullable|json',
            ]);

            // Additional validation for geom_json format
            $validator->after(function ($validator) use ($request) {
                if ($request->filled('geom_json')) {
                    $geomData = json_decode($request->geom_json, true);
                    if (json_last_error() !== JSON_ERROR_NONE) {
                        $validator->errors()->add('geom_json', 'Format GeoJSON tidak valid');
                        return;
                    }
                    
                    if (!isset($geomData['type']) || $geomData['type'] !== 'Polygon') {
                        $validator->errors()->add('geom_json', 'Tipe GeoJSON harus berupa "Polygon"');
                    }
                    
                    if (!isset($geomData['coordinates']) || !is_array($geomData['coordinates'])) {
                        $validator->errors()->add('geom_json', 'Koordinat tidak valid');
                        return;
                    }
                    
                    $coords = $geomData['coordinates'][0] ?? [];
                    if (count($coords) < 4) {
                        $validator->errors()->add('geom_json', 'Polygon membutuhkan minimal 4 titik koordinat');
                    } else {
                        $first = $coords[0];
                        $last = $coords[count($coords) - 1];
                        if ($first[0] !== $last[0] || $first[1] !== $last[1]) {
                            $validator->errors()->add('geom_json', 'Polygon harus tertutup (titik awal dan akhir harus sama)');
                        }
                    }
                }
            });

            if ($validator->fails()) {
                if ($request->ajax() || $request->wantsJson()) {
                    return response()->json([
                        'success' => false,
                        'errors' => $validator->errors()->toArray()
                    ], 422);
                }
                return redirect()->back()
                    ->withErrors($validator)
                    ->withInput();
            }

            $data = $request->only([
                'kode_petak', 'divisi', 'blok',
                'luas_area', 'zona', 'keterangan', 'aktif', 'geom_json'
            ]);

            $estate = $request->input('estate');
            $data['estate'] = str_starts_with($estate, 'Estate ') ? $estate : 'Estate ' . $estate;
            $data['aktif'] = $request->boolean('aktif');

            SubBlock::create($data);

            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => true,
                    'message' => 'Data sub block berhasil disimpan',
                    'redirect' => route('sub-blocks.index')
                ]);
            }

            return redirect()->route('sub-blocks.index')
                ->with('success', 'Data sub block berhasil disimpan');
                
        } catch (\Exception $e) {
            Log::error('Error in SubBlockController@store: ' . $e->getMessage());
            
            if ($request->ajax() || $request->wantsJson()) {
                return response()->json([
                    'success' => false,
                    'message' => 'Terjadi kesalahan saat menyimpan data: ' . $e->getMessage()
                ], 500);
            }
            
            return redirect()->back()
                ->with('error', 'Terjadi kesalahan saat menyimpan data: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function edit($id)
    {
        try {
            $subblock = SubBlock::findOrFail($id);

            // Get all unique estates with their divisions
            $estates = SubBlock::select('estate')
                ->distinct()
                ->orderBy('estate')
                ->pluck('estate');

            // Get divisions for the current estate
            $divisions = SubBlock::where('estate', $subblock->estate)
                ->select('divisi')
                ->distinct()
                ->pluck('divisi');

            // Get blocks for the current division
            $blocks = SubBlock::where('estate', $subblock->estate)
                ->where('divisi', $subblock->divisi)
                ->select('blok')
                ->distinct()
                ->pluck('blok');

            // Get all estates with their divisions for the dropdown
            $estatesWithDivisions = [];
            foreach ($estates as $estate) {
                $estatesWithDivisions[$estate] = SubBlock::where('estate', $estate)
                    ->select('divisi')
                    ->distinct()
                    ->orderBy('divisi')
                    ->pluck('divisi')
                    ->toArray();
            }

            // Set breadcrumb
            $breadcrumb = [
                ['title' => 'List Sub Block', 'url' => route('sub-blocks.index')],
                ['title' => 'Edit Sub Block']
            ];

            return view('backend.subblock.edit', [
                'subblock' => $subblock,
                'estates' => $estates,
                'divisions' => $divisions,
                'blocks' => $blocks,
                'estatesWithDivisions' => $estatesWithDivisions,
                'breadcrumb' => $breadcrumb
            ]);
        } catch (\Exception $e) {
            Log::error('Error in SubBlockController@edit: ' . $e->getMessage());
            return back()->with('error', 'Gagal memuat form edit sub block: ' . $e->getMessage());
        }
    }

    public function update(Request $request, $id)
    {
        try {
            $subBlock = SubBlock::findOrFail($id);

            $validator = Validator::make($request->all(), [
                'kode_petak' => 'required|string|max:50|unique:sub_blocks,kode_petak,' . $id,
                'estate' => 'required|string|max:100',
                'divisi' => 'required|string|max:100',
                'blok' => 'required|string|max:50',
                'luas_area' => 'required|numeric|min:0',
                'zona' => 'nullable|string|max:50',
                'keterangan' => 'nullable|string|max:255',
                'aktif' => 'boolean',
                'geom_json' => 'nullable|json',
            ]);

            // Additional validation for geom_json format
            $validator->after(function ($validator) use ($request) {
                if ($request->filled('geom_json')) {
                    $geomData = json_decode($request->geom_json, true);
                    if (json_last_error() !== JSON_ERROR_NONE) {
                        $validator->errors()->add('geom_json', 'Format GeoJSON tidak valid');
                        return;
                    }
                    
                    if (!isset($geomData['type']) || $geomData['type'] !== 'Polygon') {
                        $validator->errors()->add('geom_json', 'Tipe GeoJSON harus berupa "Polygon"');
                    }
                    
                    if (!isset($geomData['coordinates']) || !is_array($geomData['coordinates'])) {
                        $validator->errors()->add('geom_json', 'Koordinat tidak valid');
                        return;
                    }
                    
                    $coords = $geomData['coordinates'][0] ?? [];
                    if (count($coords) < 4) {
                        $validator->errors()->add('geom_json', 'Polygon membutuhkan minimal 4 titik koordinat');
                    } else {
                        $first = $coords[0];
                        $last = $coords[count($coords) - 1];
                        if ($first[0] !== $last[0] || $first[1] !== $last[1]) {
                            $validator->errors()->add('geom_json', 'Polygon harus tertutup (titik awal dan akhir harus sama)');
                        }
                    }
                }
            });

            if ($validator->fails()) {
                return redirect()->back()
                    ->withErrors($validator)
                    ->withInput();
            }

            $data = $request->only([
                'kode_petak', 'divisi', 'blok',
                'luas_area', 'zona', 'keterangan', 'aktif', 'geom_json'
            ]);

            $estate = $request->input('estate');
            $data['estate'] = str_starts_with($estate, 'Estate ') ? $estate : 'Estate ' . $estate;
            $data['aktif'] = $request->boolean('aktif');

            $subBlock->update($data);

            return redirect()->route('sub-blocks.index')
                ->with('success', 'Data sub block berhasil diperbarui');
                
        } catch (\Exception $e) {
            Log::error('Error in SubBlockController@update: ' . $e->getMessage());
            return back()->with('error', 'Gagal memperbarui data sub block: ' . $e->getMessage())
                ->withInput();
        }
    }

    public function destroy($id)
    {
        try {
            $subBlock = SubBlock::findOrFail($id);
            $subBlock->delete();

            return response()->json([
                'success' => true,
                'message' => 'Data sub block berhasil dihapus'
            ]);
        } catch (\Exception $e) {
            Log::error('Error in SubBlockController@destroy: ' . $e->getMessage());
            return response()->json([
                'success' => false,
                'message' => 'Gagal menghapus data sub block: ' . $e->getMessage()
            ], 500);
        }
    }

    public function getBlocksByDivision(Request $request)
    {
        try {
            $divisi = $request->input('divisi');

            if (empty($divisi)) {
                return response()->json([
                    'success' => false,
                    'message' => 'Parameter divisi diperlukan'
                ], 400);
            }

            $blocks = DB::table('sub_blocks')
                ->where('divisi', $divisi)
                ->select('blok')
                ->distinct()
                ->orderBy('blok')
                ->get()
                ->map(function($item) {
                    return [
                        'blok' => $item->blok,
                        'value' => $item->blok
                    ];
                });

            return response()->json($blocks);

        } catch (\Exception $e) {
            Log::error('Error in getBlocksByDivision: ' . $e->getMessage());
            return response()->json([
                'success' => false,
                'message' => 'Terjadi kesalahan saat mengambil data blok',
                'error' => $e->getMessage()
            ], 500);
        }
    }
}
